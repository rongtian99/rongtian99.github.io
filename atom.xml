<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RTed</title>
  <icon>https://www.gravatar.com/avatar/8dff07ab6d171a9d00b8cad622e176b2</icon>
  <subtitle>登峰造极</subtitle>
  <link href="https://rongtian99.github.io/atom.xml" rel="self"/>
  
  <link href="https://rongtian99.github.io/"/>
  <updated>2020-06-20T13:33:34.043Z</updated>
  <id>https://rongtian99.github.io/</id>
  
  <author>
    <name>RTed</name>
    <email>18318528216@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【虚幻4创作日志】实现基本格斗</title>
    <link href="https://rongtian99.github.io/2020/06/20/%E3%80%90%E8%99%9A%E5%B9%BB4%E5%88%9B%E4%BD%9C%E6%97%A5%E5%BF%97%E3%80%91%E5%9F%BA%E6%9C%AC%E6%A0%BC%E6%96%97/"/>
    <id>https://rongtian99.github.io/2020/06/20/%E3%80%90%E8%99%9A%E5%B9%BB4%E5%88%9B%E4%BD%9C%E6%97%A5%E5%BF%97%E3%80%91%E5%9F%BA%E6%9C%AC%E6%A0%BC%E6%96%97/</id>
    <published>2020-06-20T08:43:20.000Z</published>
    <updated>2020-06-20T13:33:34.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在实现格斗操作时，代码逻辑上需要频繁与动画交互，所以仅有小部分用代码实现，主要使用了动画蓝图，以及角色蓝图中大量的蒙太奇，但逻辑不够严谨<br>，目前仍存在许多bug，后续会继续完善，下面先来展示实现的效果；</p><h2 id="滑步"><a href="#滑步" class="headerlink" title="滑步"></a>滑步</h2><p>此处动画蒙太奇比状态机里的动画优先级高，所以滑步播放的时候，跑步不会播放，</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/89eb4099c095fcd8.png" alt="1"></p></center> <!--结束居中对齐--><p>虽然逻辑主要在蓝图里实现，不过还是贴一下滑步的代码吧，主要是将映射动画的变量公布到动画蓝图中，对动画设置动画通知，当动画运行到通知处是，则会调用事件函数进行播放动画，后面罗列的动画逻辑也是差不多。我写的逻辑太弱了，一些同时点击或操作时，会出现bug，会看到某些“很棒的画面”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*滑步输入绑定*&#x2F;</span><br><span class="line">PlayerInputComponent-&gt;BindAction(&quot;Forward&quot;, IE_DoubleClick, this, &amp;AMainCharacter::OnShuffling);</span><br><span class="line">PlayerInputComponent-&gt;BindAction(&quot;Forward&quot;, IE_Released, this, &amp;AMainCharacter::ShuffleToStop);</span><br><span class="line"></span><br><span class="line">&#x2F;*滑步*&#x2F;</span><br><span class="line">void AMainCharacter::OnShuffling()</span><br><span class="line">&#123;</span><br><span class="line">DoubleClik&#x3D;true;</span><br><span class="line">if(ShuffleToRun&#x3D;&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">GetCharacterMovement()-&gt;MaxWalkSpeed &#x3D; 10000;</span><br><span class="line">IsShuffling &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*滑步—跑步  动画声明*&#x2F;</span><br><span class="line">void AMainCharacter::EndShuffling()</span><br><span class="line">&#123;</span><br><span class="line">GetCharacterMovement()-&gt;MaxWalkSpeed &#x3D;1200;</span><br><span class="line">ShuffleToRun &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*停止滑步*&#x2F;</span><br><span class="line">void AMainCharacter::ShuffleToStop()</span><br><span class="line">&#123;</span><br><span class="line">if(DoubleClik&#x3D;&#x3D;true)</span><br><span class="line">&#123; </span><br><span class="line">GetCharacterMovement()-&gt;MaxWalkSpeed &#x3D; 1200;</span><br><span class="line">IsShuffling &#x3D; false;</span><br><span class="line">ShuffleToRun&#x3D;false;</span><br><span class="line">DoubleClik &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冲刺飞踢"><a href="#冲刺飞踢" class="headerlink" title="冲刺飞踢"></a>冲刺飞踢</h2><p> 跑步或滑步时进行攻击都能触发</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/e4ce21488c99b9c6.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="素手五段（这是其中的第四段——螺旋腿）"><a href="#素手五段（这是其中的第四段——螺旋腿）" class="headerlink" title="素手五段（这是其中的第四段——螺旋腿）"></a>素手五段（这是其中的第四段——螺旋腿）</h2><p> 这里的逻辑主要用ID设置序号，根据连续点击鼠标左键，进行遍历动画。<br> <center>  <!--开始居中对齐--></center></p><p><img src="http://i1.fuimg.com/719329/61629d4fdca01391.png" alt="1"></p> <!--结束居中对齐--><h2 id="空中坠击"><a href="#空中坠击" class="headerlink" title="空中坠击"></a>空中坠击</h2><p> 下落加速逻辑还没写好，所以效果会弱一点，当然如果有裂地特效和声效就有感觉了。</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/97e6c6f31eac1f9f.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="上踢攻击"><a href="#上踢攻击" class="headerlink" title="上踢攻击"></a>上踢攻击</h2><p> 目前存在bug，动画关闭了根运动，暂时不知如何实现滞空的逻辑，  所以上踢到空中后，动画结束，由于根运动没开启，就会立刻播放站立动画，略带突兀。</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/e4bef63974dcb6d6.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 自己的逻辑不够扎实，这几个动画的实现也磨了一段时间，还是建议在毕业前，多利用闲暇时间，敲敲算法题吧，追番打机什么的克制下[doge]，然后就是优化剩下的bug动画，后续可能进行物理碰撞和布料系统了，期待2b小姐姐裙子飘动的效果，也许下一步就要去实现他了，总之先实现点不怎么烧脑的东西先。</p> <center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/c38b7d05c3710902.png" alt="1"></p></center> <!--结束居中对齐-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在实现格斗操作时，代码逻辑上需要频繁与动画交互，所以仅有小部分用代码实现，主要使用了动画蓝图，以及角色蓝图中大量的蒙太奇，但逻辑不够严谨&lt;b
      
    
    </summary>
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/"/>
    
    
      <category term="虚幻4  创作日志" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4-%E5%88%9B%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>【虚幻4C++蓝图复刻】项目二</title>
    <link href="https://rongtian99.github.io/2020/06/02/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E8%93%9D%E5%9B%BE%E5%A4%8D%E5%88%BB%E3%80%91%E9%A1%B9%E7%9B%AE%E4%BA%8C/"/>
    <id>https://rongtian99.github.io/2020/06/02/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E8%93%9D%E5%9B%BE%E5%A4%8D%E5%88%BB%E3%80%91%E9%A1%B9%E7%9B%AE%E4%BA%8C/</id>
    <published>2020-06-02T01:12:50.000Z</published>
    <updated>2020-06-20T13:42:30.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本次复刻的C-功能-事件汇总"><a href="#本次复刻的C-功能-事件汇总" class="headerlink" title="本次复刻的C++功能/事件汇总"></a>本次复刻的C++功能/事件汇总</h2><h2 id="加速跑"><a href="#加速跑" class="headerlink" title="加速跑"></a>加速跑</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/8ba13530304febf8.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><p>事件触发函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALearnCppCharacter::SprintBegin()</span><br><span class="line">&#123;</span><br><span class="line">GetCharacterMovement()-&gt;MaxWalkSpeed &#x3D; 2200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ALearnCppCharacter::StopJumping()</span><br><span class="line">&#123;</span><br><span class="line">GetCharacterMovement()-&gt;MaxWalkSpeed &#x3D; 600;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二倍镜"><a href="#二倍镜" class="headerlink" title="二倍镜"></a>二倍镜</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/1944ddb98fffee7a.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><p>构造函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALearnCppCharacter::ALearnCppCharacter()</span><br><span class="line">&#123;</span><br><span class="line">PrimaryActorTick.bCanEverTick &#x3D; true;   &#x2F;&#x2F;开启后Tick才可生效</span><br><span class="line">···  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALearnCppCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">FloatCurve &#x3D; NewObject&lt;UCurveFloat&gt;();</span><br><span class="line">FloatCurve-&gt;FloatCurve.AddKey(0,90);          &#x2F;&#x2F;时间在前，值最高为90</span><br><span class="line">FloatCurve-&gt;FloatCurve.AddKey(0.3, 45);</span><br><span class="line"></span><br><span class="line">FOnTimelineFloatStatic TimelineCallback;</span><br><span class="line">TimelineCallback.BindUFunction(this,TEXT(&quot;DoZoom&quot;));       &#x2F;&#x2F;callback又绑定了DoZoom</span><br><span class="line">ZoomTimeline.AddInterpFloat(FloatCurve, TimelineCallback);    &#x2F;&#x2F;事件线绑定了曲线和callback, 时间线要基于Tick才能实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放大函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALearnCppCharacter::DoZoom(float FieldOfView)</span><br><span class="line">&#123;</span><br><span class="line">FirstPersonCameraComponent-&gt;SetFieldOfView(FieldOfView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定放大事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALearnCppCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">PlayerInputComponent-&gt;BindAction(&quot;Zoom&quot;, IE_Pressed, this, &amp;ALearnCppCharacter::ZoomBegin);   </span><br><span class="line">PlayerInputComponent-&gt;BindAction(&quot;Zoom&quot;, IE_Released, this, &amp;ALearnCppCharacter::ZoomStop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个时间线函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALearnCppCharacter::ZoomBegin()</span><br><span class="line">&#123;</span><br><span class="line">ZoomTimeline.Play();       &#x2F;&#x2F;摁下去后就要调用时间线类下的play函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ALearnCppCharacter::ZoomStop()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;FirstPersonCameraComponent-&gt;FieldOfView &#x3D; 90;</span><br><span class="line">ZoomTimeline.Reverse();    &#x2F;&#x2F;松开时调用Reverse函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声音与特效"><a href="#声音与特效" class="headerlink" title="声音与特效"></a>声音与特效</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/697bd02384925e33.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*在第一次被打之后变颜色后进行判断*&#x2F;</span><br><span class="line">if (IsPrimed)</span><br><span class="line">&#123;</span><br><span class="line">UGameplayStatics::PlaySoundAtLocation(GetWorld(), ExplosionSound, HitLocation);   &#x2F;&#x2F;声音发射器</span><br><span class="line">UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ExplosionEffect,HitLocation);   &#x2F;&#x2F;生成发射器，特效的发射器</span><br><span class="line">Destroy();  &#x2F;&#x2F;圆柱体消亡</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本次复刻的C-功能-事件汇总&quot;&gt;&lt;a href=&quot;#本次复刻的C-功能-事件汇总&quot; class=&quot;headerlink&quot; title=&quot;本次复刻的C++功能/事件汇总&quot;&gt;&lt;/a&gt;本次复刻的C++功能/事件汇总&lt;/h2&gt;&lt;h2 id=&quot;加速跑&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/"/>
    
    
      <category term="虚幻4 C++ 蓝图复刻 入门项目" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4-C-%E8%93%9D%E5%9B%BE%E5%A4%8D%E5%88%BB-%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>【虚幻4C++蓝图复刻】项目一</title>
    <link href="https://rongtian99.github.io/2020/06/01/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E5%A4%8D%E5%88%BB%E8%93%9D%E5%9B%BE%E3%80%91%E9%A1%B9%E7%9B%AE%E4%B8%80/"/>
    <id>https://rongtian99.github.io/2020/06/01/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E5%A4%8D%E5%88%BB%E8%93%9D%E5%9B%BE%E3%80%91%E9%A1%B9%E7%9B%AE%E4%B8%80/</id>
    <published>2020-06-01T04:56:51.000Z</published>
    <updated>2020-06-20T13:47:29.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本次复刻的C-功能-事件汇总"><a href="#本次复刻的C-功能-事件汇总" class="headerlink" title="本次复刻的C++功能/事件汇总"></a>本次复刻的C++功能/事件汇总</h2><blockquote><p>EventHit<br>Cast识别子弹<br>SetMaterial被击变红<br>Delay<br>EventTick<br>自动转向</p></blockquote><h2 id="EventHit"><a href="#EventHit" class="headerlink" title="EventHit"></a>EventHit</h2><p>c++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这是一个事件，用于监听圆柱体是否被击中</span><br><span class="line">void ATargetStaticMeshActor::NotifyHit(UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult&amp; Hit)</span><br><span class="line">&#123;</span><br><span class="line">Super::NotifyHit(MyComp, Other, OtherComp, bSelfMoved, HitLocation, HitNormal, NormalImpulse, Hit);   &#x2F;&#x2F;调用父类的构造方法</span><br><span class="line">&#x2F;&#x2F;下面就可以写自己的逻辑了</span><br><span class="line">if (Other &#x3D;&#x3D; nullptr) return;</span><br><span class="line">if (GEngine)</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(&quot;NotifyHit&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：击中物体圆柱体后 左边会显示的文本信息</p><h2 id="Cast识别子弹"><a href="#Cast识别子弹" class="headerlink" title="Cast识别子弹"></a>Cast识别子弹</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/28a49592b6f06abf.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALearnCppProjectile* projectile &#x3D; Cast&lt;ALearnCppProjectile&gt;(Other);    &#x2F;&#x2F;将别的物体转化为子弹类</span><br><span class="line">if (projectile !&#x3D; nullptr) &#123;</span><br><span class="line">    if (GEngine)</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(&quot;ALearnCppProjectile&quot;));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (GEngine)</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(&quot;Not ALearnCppProjectile&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：若击中物体为子弹类，左边会显示相应的文本信息</p><h2 id="SetMaterial被击变红"><a href="#SetMaterial被击变红" class="headerlink" title="SetMaterial被击变红"></a>SetMaterial被击变红</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/008942ce250e5afe.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*这里被击打后变红*&#x2F;</span><br><span class="line">UStaticMeshComponent* staticMesh&#x3D;GetStaticMeshComponent();      &#x2F;&#x2F;获取当前的网格体</span><br><span class="line">staticMesh-&gt;SetMaterial(0, TargetRed);  &#x2F;&#x2F;然后设置它的材质，  将TargetRed公布到蓝图并可在细节面板编辑，然后传回。</span><br></pre></td></tr></table></figure><p>效果：圆柱体被子弹击中后会变材质</p><h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/f2189670e1469efa.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLatentActionInfo LatentInfo;</span><br><span class="line">LatentInfo.Linkage &#x3D; 0;</span><br><span class="line">LatentInfo.CallbackTarget &#x3D; this;  &#x2F;&#x2F;delay 什么对象</span><br><span class="line">LatentInfo.ExecutionFunction &#x3D; &quot;NotifyHitCallback&quot;;    &#x2F;&#x2F;需要延迟调用的函数名</span><br><span class="line">LatentInfo.UUID &#x3D; __LINE__;&#x2F;&#x2F;用于区分该对象的不同delay</span><br><span class="line">UKismetSystemLibrary::Delay(GetWorld(), 0.5, LatentInfo);   &#x2F;&#x2F;LatentInfo为结构体</span><br></pre></td></tr></table></figure><p>效果：延迟一段时间后圆柱体颜色变回来</p><h2 id="EventTick"><a href="#EventTick" class="headerlink" title="EventTick"></a>EventTick</h2><p>蓝图</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/d614d05a8f8fc311.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ATargetStaticMeshActor::Tick(float DeltaSeconds)</span><br><span class="line">&#123;</span><br><span class="line">Super::Tick(DeltaSeconds);</span><br><span class="line">AddActorLocalOffset(UKismetMathLibrary::Normal(Direction) * DeltaSeconds * 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆柱体会一直某个方向位移</p><h2 id="自动转向"><a href="#自动转向" class="headerlink" title="自动转向"></a>自动转向</h2><p>蓝图：</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/b02731f98feee247.png" alt="1"></p></center> <!--结束居中对齐--><p>C++代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ATargetStaticMeshActor::TickCallback()</span><br><span class="line">&#123;</span><br><span class="line">Direction *&#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每帧调用</span><br><span class="line">void ATargetStaticMeshActor::Tick(float DeltaSeconds)</span><br><span class="line">&#123;</span><br><span class="line">Super::Tick(DeltaSeconds);</span><br><span class="line">AddActorLocalOffset(UKismetMathLibrary::Normal(Direction) * DeltaSeconds * 200);</span><br><span class="line">FLatentActionInfo LatentInfo;</span><br><span class="line">LatentInfo.Linkage &#x3D; 0;</span><br><span class="line">LatentInfo.CallbackTarget &#x3D; this;  &#x2F;&#x2F;delay 什么对象</span><br><span class="line">LatentInfo.ExecutionFunction &#x3D; &quot;TickCallback&quot;;</span><br><span class="line">LatentInfo.UUID &#x3D; __LINE__;&#x2F;&#x2F;用于区分该对象的不同delay</span><br><span class="line">UKismetSystemLibrary::Delay(GetWorld(), 3, LatentInfo);   &#x2F;&#x2F;LatentInfo为结构体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：每隔一段时间后圆柱体转向</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本次复刻的C-功能-事件汇总&quot;&gt;&lt;a href=&quot;#本次复刻的C-功能-事件汇总&quot; class=&quot;headerlink&quot; title=&quot;本次复刻的C++功能/事件汇总&quot;&gt;&lt;/a&gt;本次复刻的C++功能/事件汇总&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;EventHi
      
    
    </summary>
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/"/>
    
    
      <category term="虚幻4 C++ 蓝图复刻 入门项目" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4-C-%E8%93%9D%E5%9B%BE%E5%A4%8D%E5%88%BB-%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】银行家算法解析</title>
    <link href="https://rongtian99.github.io/2020/05/30/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%AA%E4%BA%BA%E8%A7%A3%E6%9E%90/"/>
    <id>https://rongtian99.github.io/2020/05/30/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%AA%E4%BA%BA%E8%A7%A3%E6%9E%90/</id>
    <published>2020-05-30T02:27:37.000Z</published>
    <updated>2020-06-20T13:47:25.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>老师给予了实验报告的八大选题，由于以前看过银行家算法的算法模拟，于是就决定了该选题，现在需要撰写该实验报告的代码分析，于是决定通过markdown的形式来解析的同时再次加深理解。</p><h2 id="死锁预防——银行家算法的背景"><a href="#死锁预防——银行家算法的背景" class="headerlink" title="死锁预防——银行家算法的背景"></a>死锁预防——银行家算法的背景</h2><p>名字的缘由：</p><blockquote><p>一家银行原本有100亿资金</p><p>公司a贷款已经了60亿，现在其公司项目还需10亿进行资金周转</p><p>公司b代款已经了40亿，现在其公司发展良好，可收回20亿元</p><p>公司c想要贷款80亿元</p></blockquote><p>在这种情况下，如果你是这家银行的经理，你会如何进行资金流转呢？ 答案自然不言而喻了。<br>这个银行的资金便是资源，而各个公司便是进程。在操作系统中，者是一个很好的映射，系统中的内存空间等资源被许多进程需求，但资源是有限的，操作系统就需要根据一定的规则进行分配，才能避免进程发生死锁。那么这规则是怎样的呢？</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>安全序列</p><p>安全序列是指对当前申请资源的进程排出一个序列，保证按照这个序列分配资源完成进程<br>我们假设有进程P1,P2,…..Pn<br>则安全序列要求满足：Pi(1&lt;=i&lt;=n)需要资源&lt;=剩余资源 + 分配给Pj(1 &lt;= j &lt; i)资源（这里的pj资源是等其运行完后释放出来的资源）</p><p>定义以下数据结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n,m; &#x2F;&#x2F;系统中进程总数n和资源种类总数m</span><br><span class="line">int Available[1..m]; &#x2F;&#x2F;资源当前可用总量</span><br><span class="line">int Allocation[1..n,1..m]; &#x2F;&#x2F;当前给分配给每个进程的各种资源数量</span><br><span class="line">int Need[1..n,1..m];&#x2F;&#x2F;当前每个进程还需分配的各种资源数量</span><br><span class="line">int Work[1..m]; &#x2F;&#x2F;当前可分配的资源</span><br><span class="line">bool Finish[1..n]; &#x2F;&#x2F;进程是否结束</span><br></pre></td></tr></table></figure><h2 id="安全判定算法"><a href="#安全判定算法" class="headerlink" title="安全判定算法"></a>安全判定算法</h2><p>1.初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Work &#x3D; Available（动态记录当前剩余资源）</span><br><span class="line">Finish[i] &#x3D; false（设定所有进程均未完成）</span><br></pre></td></tr></table></figure><p>2.查找可执行进程Pi（未完成但目前剩余资源可满足其需要，这样的进程是能够完成的）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Finish[i] &#x3D; false          </span><br><span class="line">Need[i] &lt;&#x3D; Work </span><br><span class="line">如果没有这样的进程Pi，则跳转到第4步</span><br></pre></td></tr></table></figure><p>3.归还其占用的资源.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Finish[i] &#x3D; true           </span><br><span class="line">Work &#x3D; Work +Allocation[i]</span><br><span class="line">GOTO 第2步，继续查找</span><br></pre></td></tr></table></figure><p>4.如果所有进程Pi都是能完成的，即Finish[i]=ture<br>则系统处于安全状态，否则系统处于不安全状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean Found;</span><br><span class="line">Work &#x3D; Available; Finish[1..n] &#x3D; false; </span><br><span class="line">while(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;不断的找可执行进程（伪代码）</span><br><span class="line">   Found &#x3D; false;</span><br><span class="line">   for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;</span><br><span class="line">     if(Finish[i]&#x3D;&#x3D;false &amp;&amp; Need[i]&lt;&#x3D;Work)&#123;</span><br><span class="line">        Work &#x3D; Work + Allocation[i];&#x2F;&#x2F;把放出去的贷款也当做自己的资产</span><br><span class="line">        Finish[i] &#x3D; true; </span><br><span class="line">        Found &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   if(Found&#x3D;&#x3D;false)break;</span><br><span class="line"> &#125;</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++) </span><br><span class="line">  if(Finish[i]&#x3D;&#x3D;false)return “deadlock”; &#x2F;&#x2F;如果有进程是完不成的，那么就是有死锁</span><br></pre></td></tr></table></figure><h2 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h2><p>之前说完了怎么判定当前情况是否安全，下面就是说当有进程新申请资源的时候如何处理。<br>我们将第i个进程请求的资源数记为Requests[i]</p><p>算法流程：<br>1.如果Requests[i]&lt;=Need[i]，则转到第二步。否则，返回异常。这一步是控制进程申请的资源不得大于需要的资源<br>2.如果Requests[i]&lt;=Available，则转到第三步，否则Pi等待资源。<br>3.如果满足前两步，那么做如下操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Available &#x3D; Available -Requests[i]</span><br><span class="line">Allocation &#x3D; Allocation[i]+Requests[i]</span><br><span class="line">Need[i]&#x3D;Need[i]-Requests[i]</span><br><span class="line">调用安全判定算法，检查是否安全</span><br><span class="line">if(安全)</span><br><span class="line">&#123;</span><br><span class="line">    申请成功，资源分配</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    申请失败，资源撤回。第三步前几个操作进行逆操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序源码："><a href="#程序源码：" class="headerlink" title="程序源码："></a>程序源码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxpro &#x3D; 100;  &#x2F;&#x2F;最大进程数</span><br><span class="line">const int maxres &#x3D; 100;  &#x2F;&#x2F;最大资源数</span><br><span class="line"></span><br><span class="line">int pro; &#x2F;&#x2F;进程数</span><br><span class="line">int res; &#x2F;&#x2F;资源数</span><br><span class="line"></span><br><span class="line">int request[maxres];&#x2F;&#x2F;进程请求资源数目</span><br><span class="line">&#x2F;&#x2F;int R[maxres]; &#x2F;&#x2F;总资源</span><br><span class="line">int V[maxres]; &#x2F;&#x2F;可提供</span><br><span class="line">int C[maxpro][maxres]; &#x2F;&#x2F;总需求</span><br><span class="line">int A[maxpro][maxres]; &#x2F;&#x2F;已分配</span><br><span class="line">int vis[maxpro]; &#x2F;&#x2F;表示第i个进程是否已分配资源，1表示已分配</span><br><span class="line">int path[maxpro];  &#x2F;&#x2F;路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安全状态判断</span><br><span class="line">bool safe() &#123;</span><br><span class="line">    int curV[maxres]; &#x2F;&#x2F;目前可提供资源</span><br><span class="line">    for(int i &#x3D; 0; i &lt; res; i++)</span><br><span class="line">        curV[i] &#x3D; V[i];</span><br><span class="line"></span><br><span class="line">    memset(vis, 0, sizeof(vis));</span><br><span class="line"></span><br><span class="line">    int flag &#x3D; 1;</span><br><span class="line">    for(int i1 &#x3D; 0; i1 &lt; pro; i1++) &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i &#x3D; 0; i &lt; pro; i++) &#123;</span><br><span class="line">            if(vis[i] &#x3D;&#x3D; 1) continue;</span><br><span class="line">            int flagpro &#x3D; 1; &#x2F;&#x2F;0表示未找到合适的进程</span><br><span class="line">            for(int j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">                if(C[i][j] - A[i][j] &gt; curV[j]) &#123;</span><br><span class="line">                    flagpro &#x3D; 0; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flagpro) &#123;</span><br><span class="line">                path[i1] &#x3D; i;</span><br><span class="line">                vis[i] &#x3D; 1;</span><br><span class="line">                for(int k &#x3D; 0; k &lt; res; k++)</span><br><span class="line">                    curV[k] +&#x3D; A[i][k];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &#x3D;&#x3D; pro) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return flag &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print() &#123;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;显示当前状态&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;总需求矩阵C&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; pro; i++) &#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">            printf(&quot;%2d &quot;, C[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;已分配矩阵A&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; pro; i++) &#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">            printf(&quot;%2d &quot;, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;需求矩阵N (C-A)&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; pro; i++) &#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">            printf(&quot;%2d &quot;, C[i][j] - A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;* cout &lt;&lt; &quot;总资源向量R&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; res; i++)</span><br><span class="line">        cout &lt;&lt; R[i] &lt;&lt; &#39; &#39;;</span><br><span class="line">    cout &lt;&lt; endl;*&#x2F;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;可提供资源向量V&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; res; i++)</span><br><span class="line">        cout &lt;&lt; V[i] &lt;&lt; &#39; &#39;;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bank() &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; &quot;请选择首进程资源输入1，显示当前状态输入2, 结束输入3&quot; &lt;&lt; endl;</span><br><span class="line">        int k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        if(k &#x3D;&#x3D; 3) break;</span><br><span class="line">        else if(k &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            print(); continue;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;请输入请求资源的进程编号, 进程号为0 - &quot; &lt;&lt; pro - 1 &lt;&lt; endl;</span><br><span class="line">        int proindex;</span><br><span class="line">        cin &gt;&gt; proindex;</span><br><span class="line">        cout &lt;&lt; &quot;请输入此进程每个资源需求数目&quot; &lt;&lt; endl;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; res; i++)</span><br><span class="line">            cin &gt;&gt; request[i];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;检查该进程所需要的资源是否已超过它所宣布的最大值</span><br><span class="line">        int flag &#x3D; 1;  &#x2F;&#x2F;flag为1表示没超过，为0表示超过</span><br><span class="line">        for(int i &#x3D; 0; i &lt; res; i++) &#123;</span><br><span class="line">            if(request[i] + A[proindex][i] &gt; C[proindex][i])</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;资源请求失败，该进程所需要的资源已超过总资源的最大值&quot; &lt;&lt; endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;检查系统当前是否有足够资源满足该进程的请求</span><br><span class="line">        flag &#x3D; 1;  &#x2F;&#x2F;flag为1有足够资源，为0表示没有</span><br><span class="line">        for(int i &#x3D; 0; i &lt; res; i++) &#123;</span><br><span class="line">            if(request[i] &gt; V[i])</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;资源请求失败，系统当前没有有足够资源满足该进程的请求&quot; &lt;&lt; endl;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;尝试分配资源给该进程，得到新的状态</span><br><span class="line">        for(int i &#x3D; 0; i &lt; res; i++) &#123;</span><br><span class="line">            A[proindex][i] +&#x3D; request[i]; &#x2F;&#x2F;已分配资源矩阵A更新</span><br><span class="line">            V[i] -&#x3D; request[i]; &#x2F;&#x2F;可提供资源向量V更新</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;执行安全性算法，若该新状态是安全的，则分配完成；若新状态是不安全的，则恢复原状态，阻塞该进程</span><br><span class="line">        if(safe()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;资源分配成功&quot; &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;安全路径是：&quot;;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; pro; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; pro; i++) &#123;</span><br><span class="line">                int j;</span><br><span class="line">                for(j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">                    if(A[i][j] !&#x3D; C[i][j])</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j &#x3D;&#x3D; res)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(j &#x3D; 0; j &lt; res; j++) &#123;</span><br><span class="line">                        V[j] +&#x3D; A[i][j];</span><br><span class="line">                        A[i][j] &#x3D; 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else  &#123;</span><br><span class="line">            cout &lt;&lt; &quot;该状态不安全，资源分配失败&quot; &lt;&lt; endl;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; res; i++) &#123;</span><br><span class="line">                A[proindex][i] -&#x3D; request[i]; &#x2F;&#x2F;已分配资源矩阵A更新</span><br><span class="line">                V[i] +&#x3D; request[i]; &#x2F;&#x2F;可提供资源向量V更新</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;请输入总资源数: &quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; res;</span><br><span class="line">    cout &lt;&lt; &quot;请输入总进程数: &quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; pro;</span><br><span class="line">&#x2F;*</span><br><span class="line">    cout &lt;&lt; &quot;请分别输入每个资源的数目(R向量)，目前有&quot; &lt;&lt; res &lt;&lt; &quot;个资源&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; res; i++)</span><br><span class="line">        cin &gt;&gt; R[i];*&#x2F;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请分别输入每个资源的可分配数目，目前有&quot; &lt;&lt; res &lt;&lt; &quot;个资源&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0;  i&lt; res; i++)</span><br><span class="line">        cin &gt;&gt; V[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入总需求矩阵C，共有&quot; &lt;&lt; res &lt;&lt; &quot;个资源，&quot; &lt;&lt; pro &lt;&lt; &quot;个进程&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;格式: 每行输入单个进程的总需求资源数目, 输入&quot; &lt;&lt; pro &lt;&lt; &quot;行&quot; &lt;&lt; endl;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; pro; i++)</span><br><span class="line">        for(int j &#x3D; 0 ; j &lt; res; j++)</span><br><span class="line">            cin &gt;&gt; C[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;请输入已分配矩阵A，共有&quot; &lt;&lt; res &lt;&lt; &quot;个资源，&quot; &lt;&lt; pro &lt;&lt; &quot;个进程&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;格式: 每行输入单个进程的已分配资源数目, 输入&quot; &lt;&lt; pro &lt;&lt; &quot;行&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0; i &lt; pro; i++)</span><br><span class="line">        for(int j &#x3D; 0 ; j &lt; res; j++)</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line"></span><br><span class="line">    bank();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;老师给予了实验报告的八大选题，由于以前看过银行家算法的算法模拟，于是就决定了该选题，现在需要撰写该实验报告的代码分析，于是决定通过markd
      
    
    </summary>
    
    
      <category term="程序猿必修" scheme="https://rongtian99.github.io/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%BF%85%E4%BF%AE/"/>
    
    
      <category term="操作系统" scheme="https://rongtian99.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习笔记" scheme="https://rongtian99.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【blender】渲染Tifa女神&amp;萨菲罗斯</title>
    <link href="https://rongtian99.github.io/2020/05/28/%E3%80%90blender%E3%80%91%E6%B8%B2%E6%9F%93Tifa%E5%A5%B3%E7%A5%9E-%E8%90%A8%E8%8F%B2%E7%BD%97%E6%96%AF/"/>
    <id>https://rongtian99.github.io/2020/05/28/%E3%80%90blender%E3%80%91%E6%B8%B2%E6%9F%93Tifa%E5%A5%B3%E7%A5%9E-%E8%90%A8%E8%8F%B2%E7%BD%97%E6%96%AF/</id>
    <published>2020-05-28T01:56:01.000Z</published>
    <updated>2020-06-20T13:33:30.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tifa"><a href="#Tifa" class="headerlink" title="Tifa"></a>Tifa</h2><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/5267057cea15e566.png" alt="1"></p></center> <!--结束居中对齐--><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/c68c6565ff597091.png" alt="1"></p></center> <!--结束居中对齐--><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/874867131c4077ba.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/9d82b876e8d6922f.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="萨菲罗斯"><a href="#萨菲罗斯" class="headerlink" title="萨菲罗斯"></a>萨菲罗斯</h2><p>实时渲染，我家显卡不给力啊</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/bb243e5a0acba82d.png" alt="1"></p></center> <!--结束居中对齐--><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/46025dfab39753aa.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><center>  <!--开始居中对齐--><p><img src="http://i2.tiimg.com/719329/dd22cbae40fd0617.png" alt="1"></p></center> <!--结束居中对齐-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tifa&quot;&gt;&lt;a href=&quot;#Tifa&quot; class=&quot;headerlink&quot; title=&quot;Tifa&quot;&gt;&lt;/a&gt;Tifa&lt;/h2&gt;&lt;center&gt;  &lt;!--开始居中对齐--&gt;

&lt;p&gt;&lt;img src=&quot;http://i1.fuimg.com/719329/
      
    
    </summary>
    
    
      <category term="blender" scheme="https://rongtian99.github.io/categories/blender/"/>
    
    
      <category term="blender" scheme="https://rongtian99.github.io/tags/blender/"/>
    
      <category term="人物渲染" scheme="https://rongtian99.github.io/tags/%E4%BA%BA%E7%89%A9%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【虚幻4人物绑定】捕获一只2b小姐姐</title>
    <link href="https://rongtian99.github.io/2020/05/27/%E3%80%90%E8%99%9A%E5%B9%BB4%E4%BA%BA%E7%89%A9%E7%BB%91%E5%AE%9A%E3%80%91%E6%8D%95%E8%8E%B7%E4%B8%80%E5%8F%AA2b%E5%B0%8F%E5%A7%90%E5%A7%90/"/>
    <id>https://rongtian99.github.io/2020/05/27/%E3%80%90%E8%99%9A%E5%B9%BB4%E4%BA%BA%E7%89%A9%E7%BB%91%E5%AE%9A%E3%80%91%E6%8D%95%E8%8E%B7%E4%B8%80%E5%8F%AA2b%E5%B0%8F%E5%A7%90%E5%A7%90/</id>
    <published>2020-05-27T14:24:01.000Z</published>
    <updated>2020-05-28T01:52:02.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这些天，一直在进行ue4里2b模型的绑定，中途踩了无数的坑，也遇到了很多大佬，用梯子、论坛、q群、博客、官方文档，真就兵来将挡，水来土淹。还好每一个坑最后都能解决或者用另一种途径逃课，收获还是不少的。  </p><h2 id="【步骤一】游戏解包"><a href="#【步骤一】游戏解包" class="headerlink" title="【步骤一】游戏解包"></a>【步骤一】游戏解包</h2><p>由于国内模型与动作源文件资源较为匮乏，自然首选搬梯子到国外去啦，有个模型资源很多的外国网站：deviantart（简称d站），只要一搜索就能出你想要的游戏模型，多数为xps格式的文件，配合blender使用（blender要装xps的插件才能使用），如果你还想获得模型的动作文件的话，我建议还是解包来的快些，这里推荐一个关于尼尔机械纪元解包视频教程：<a href="https://www.bilibili.com/video/BV1ox411o7Tj/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">尼尔解包教程</a>，up主很良心，除了需要自己装个python配置环境，其他需要的工具都整合到压缩包里了，甚至连解包出来的文件夹都给你准备了（真棒！） 获取方法可以看他视频下方的简介。  </p><h2 id="【步骤二】材质贴图"><a href="#【步骤二】材质贴图" class="headerlink" title="【步骤二】材质贴图"></a>【步骤二】材质贴图</h2><p>这里如果没有学过一些关于材质的知识，可能比较难受（别问我怎么知道的），即使学了一些，但软件或者不同模型之间使用的着色器也是不一样的，所以只能遇到坑多问相关的qq群，网上太少关于材质的解答了。因为解包出来的模型是重叠的（角色的不同装饰重叠在一起），我先用blender将模型拆分了一下  </p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/c994cc4a2aa6c8a6.png" alt="1"></p></center> <!--结束居中对齐--><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/5c12ce73916d6701.png" alt="1"></p></center> <!--结束居中对齐--><p>拆分前后的对比，是不是有点感觉了呢，压抑住心中的激动，打开了ue4，进入材质编辑器，节点的各引脚代表什么，我就不解释，可以看一下ue4官方文档关于材质的说明，尽量根据贴图的结尾字母提示和图片的样式来确定是应该连接那个引脚（最基本的贴图了），至于如果还想细致调节，就得好好学一学材质，里面有很多材质函数，网上教程比较少，我也还没有找到较为全面的教程，这里的是2b头发的材质蓝图。  </p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/d533de2fb46454e4.png" alt="1"></p></center> <!--结束居中对齐--><p>至此模型就已经出来了！</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/60bbfbe3a968568f.png" alt="1"></p></center> <!--结束居中对齐--><h2 id="【步骤三】-模型动画"><a href="#【步骤三】-模型动画" class="headerlink" title="【步骤三】 模型动画"></a>【步骤三】 模型动画</h2><p>这里是最坑的地方了，涉及骨骼的东西，实在是太恐怖了，blender导出的骨骼，会在骨骼树叶子节点加上一个骨骼（默认，可以去掉这个钩），而这个骨骼是没有加权重的，导入ue时，就报错了</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/bc269b51f3bf2693.png" alt="1"></p></center> <!--结束居中对齐--><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/a3621b0a27722480.jpg" alt="1"></p></center> <!--结束居中对齐--><p>ue4里动画会没掉（然而这个在ue4没动画的模型导回到blender又有了，真是怪了），网上一点信息也找不到，最后问群里大佬，大佬介绍了淘宝上的几款关于blender配合ue4的插件，然而花了一笔小钱后还是没有解决问题（也许是我不会用那个插件把），最后自己撞来撞去，撞到了一个逃课的方法，我关闭了那个在叶子节点添加骨骼的按钮</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/dc0f5efa700fe26b.png" alt="1"></p></center> <!--结束居中对齐--><p>然后利用了骨骼重定向了一开始从游戏解包出来的fbx模型的动画（没有经过blender去除2b的外部装甲，但动画是一样的），解决了。  如果有大佬告知更高级的解法，麻烦私信一下我，感激不尽啊！</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/0e5aabadfb808b26.png" alt="1"></p></center> <!--结束居中对齐-->最后2b的动画+模型就出来了！人物绑定完成，至于武器绑定就之后再考虑吧。]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这些天，一直在进行ue4里2b模型的绑定，中途踩了无数的坑，也遇到了很多大佬，用梯子、论坛、q群、博客、官方文档，真就兵来将挡，水来土淹。还
      
    
    </summary>
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/"/>
    
      <category term="blender" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/blender/"/>
    
    
      <category term="blender" scheme="https://rongtian99.github.io/tags/blender/"/>
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4/"/>
    
      <category term="人物绑定" scheme="https://rongtian99.github.io/tags/%E4%BA%BA%E7%89%A9%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>【虚幻4】C++蓝图交叉调用</title>
    <link href="https://rongtian99.github.io/2020/05/21/%E3%80%90%E8%99%9A%E5%B9%BB4%E3%80%91C-%E8%93%9D%E5%9B%BE%E4%BA%A4%E5%8F%89%E8%B0%83%E7%94%A8/"/>
    <id>https://rongtian99.github.io/2020/05/21/%E3%80%90%E8%99%9A%E5%B9%BB4%E3%80%91C-%E8%93%9D%E5%9B%BE%E4%BA%A4%E5%8F%89%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-21T07:10:33.000Z</published>
    <updated>2020-05-21T07:52:05.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><a href="https://docs.unrealengine.com/zh-CN/Programming/Introduction/index.html" target="_blank" rel="noopener">ue4的c++编程简介</a></p><h2 id="使用虚幻4的正确姿势"><a href="#使用虚幻4的正确姿势" class="headerlink" title="使用虚幻4的正确姿势"></a>使用虚幻4的正确姿势</h2><p>最佳方法是使用C++构建基本Gameplay系统和性能关键代码，用蓝图自定义行为或从C++构建块创建组合式行为。</p><p>那么如何实现C++代码和蓝图的共享和通信呢？</p><h2 id="蓝图边界交叉调用方法"><a href="#蓝图边界交叉调用方法" class="headerlink" title="蓝图边界交叉调用方法"></a>蓝图边界交叉调用方法</h2><p>###1.让C++代码能够调用蓝图中定义的函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintImplementableEvent, Category&#x3D;&quot;Damage&quot;)</span><br><span class="line">void CalledFromCpp();</span><br></pre></td></tr></table></figure><p>设计师在蓝图编辑器中添加函数节点，则在后台，虚幻引擎生成基本C++函数实现，如果所提及蓝图<br>不为这种方法提供函数体，则函数行为就像没有实体行为的C++函数一样：不执行任何操作。</p><p>如果想要提供C++默认实现，同时仍允许蓝图覆盖此方法（类似于默认构造函数）则需如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintNativeEvent, Category&#x3D;&quot;Damage&quot;)</span><br><span class="line">void CalledFromCpp();</span><br></pre></td></tr></table></figure><p>其默认实现则需生成一个新的函数声明（由工具生成如下）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void AMyActor::CalledFromCpp_Implementation()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;实现代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###2.让蓝图能使用C++代码中定义的函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line">class AMyActor : public AActor</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Damage&quot;)</span><br><span class="line">    int32 TotalDamage;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category&#x3D;&quot;Damage&quot;)</span><br><span class="line">    float DamageTimeInSeconds;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadOnly, VisibleAnywhere, Transient, Category&#x3D;&quot;Damage&quot;)</span><br><span class="line">    float DamagePerSecond;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将C++代码中的变量公布到蓝图中即可进行编辑（效果如下）</p><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/86e0eb413abf8f49.jpg" alt></p></center> <!--结束居中对齐--><p>为了使设计师在编辑器修改参数后，使目标对象对应的值发生更改，则需要添加钩，进行挂连。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void AMyActor::PostInitProperties()</span><br><span class="line">&#123;</span><br><span class="line">    Super::PostInitProperties();</span><br><span class="line"></span><br><span class="line">    CalculateValues();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AMyActor::CalculateValues()</span><br><span class="line">&#123;</span><br><span class="line">    DamagePerSecond &#x3D; TotalDamage &#x2F; DamageTimeInSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if WITH_EDITOR    &#x2F;&#x2F;是否进行了编辑</span><br><span class="line">void AMyActor::PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent)</span><br><span class="line">&#123;</span><br><span class="line">    CalculateValues();</span><br><span class="line"></span><br><span class="line">    Super::PostEditChangeProperty(PropertyChangedEvent);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.unrealengine.com/zh-CN/Programming/Introduction/
      
    
    </summary>
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/categories/%E8%99%9A%E5%B9%BB4/"/>
    
    
      <category term="学习笔记" scheme="https://rongtian99.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4/"/>
    
  </entry>
  
  <entry>
    <title>【虚幻4C++类】GameModeBase类</title>
    <link href="https://rongtian99.github.io/2020/05/19/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E7%B1%BB%E3%80%91GameModeBase%E7%B1%BB/"/>
    <id>https://rongtian99.github.io/2020/05/19/%E3%80%90%E8%99%9A%E5%B9%BB4C-%E7%B1%BB%E3%80%91GameModeBase%E7%B1%BB/</id>
    <published>2020-05-19T13:55:40.000Z</published>
    <updated>2020-05-21T07:52:11.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><a href="https://docs.unrealengine.com/zh-CN/Programming/Tutorials/FirstPersonShooter/1/index.html" target="_blank" rel="noopener">UE4官方文档-&gt;第一人称射击游戏教程-&gt;设置项目-&gt;游戏模式基础类</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>游戏模式定义游戏的规则和胜利条件。游戏模式用于设置部分基础游戏性框架类型（包括Pawn，玩家控制器和HUD）的<br>类别。</p><p>官方文档在该位置编写了一个GameModeBase类用于ue4关卡运行时在屏幕左上角显示相关信息（一种游戏模式，一种规则）</p><h2 id="实现示例图"><a href="#实现示例图" class="headerlink" title="实现示例图"></a>实现示例图</h2><center>  <!--开始居中对齐--><p><img src="http://i1.fuimg.com/719329/cf83085cebec2080.jpg" alt="UE4关卡运行图"></p></center> <!--结束居中对齐--><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;GameFramework&#x2F;GameModeBase.h&quot;</span><br><span class="line">#include &quot;FPSProjectGameModeBase.generated.h&quot;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line">class FPSPROJECT_API AFPSProjectGameModeBase : public AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line">virtual void StartPlay() override&#123;</span><br><span class="line">Super::StartPlay();      &#x2F;&#x2F;子类的StartPlay函数继承父类该函数</span><br><span class="line">&#x2F;&#x2F;同时子类重的StartPlay函数要完成以下</span><br><span class="line">if (GEngine)  &#x2F;&#x2F;若ue4开始运行时</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;显示调试信息五秒</span><br><span class="line">&#x2F;&#x2F;-1“键”值（首个参数）说明我们无需更新或刷新此消息</span><br><span class="line">GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Yellow, TEXT(&quot;Hello World, this is FPSGameModeBase!&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;       &#x2F;&#x2F;通过此函数声明覆盖StartPlay函数，游戏开始时便会将日志消息显示到屏幕上</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.unrealengine.com/zh-CN/Programming/Tutorials/Fir
      
    
    </summary>
    
    
    
      <category term="虚幻4" scheme="https://rongtian99.github.io/tags/%E8%99%9A%E5%B9%BB4/"/>
    
  </entry>
  
</feed>
